import logging
import random
import datetime
import time

# Configure logging to provide detailed insights into the script's operation
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')

# Define the types of transactions available, representing typical banking operations
transaction_types = ['Deposit', 'Withdrawal', 'Transfer']

def generate_random_accounts(num_accounts):
    """
    Generate a fixed number of random bank account numbers.
    Each account number is a unique random 9-digit number, simulating a typical bank account.

    Args:
        num_accounts (int): Number of random account numbers to generate.

    Returns:
        list: A list of unique account numbers as strings.
    """
    logging.info(f"Generating {num_accounts} random account numbers.")
    return [str(random.randint(100000000, 999999999)) for _ in range(num_accounts)]

def generate_transactions(accounts, filename):
    """
    Create a list of transactions for a given set of account numbers.
    Transactions are generated by simulating random activities such as deposits, withdrawals, and transfers.
    Each transaction includes a timestamp, account number, type, amount, and source file.

    Args:
        accounts (list): A list of account numbers.
        filename (str): The name of the file from which the transactions are generated.

    Returns:
        list: A list of transaction strings formatted for file writing.
    """
    transactions = []
    num_transactions = int(random.uniform(10, 100))
    logging.info(f"Generating {num_transactions} transactions.")
    for _ in range(num_transactions):
        account_number = random.choice(accounts)
        transaction_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        transaction_type = random.choice(transaction_types)
        amount = round(random.uniform(10, 10000), 2)
        transaction = f"{transaction_time},{account_number},{transaction_type},{amount},{filename}\n"
        transactions.append(transaction)
        # Introduce a random delay to mimic real-time data generation
        # time.sleep(random.uniform(0.1, 0.5))
    return transactions

def write_transactions_to_file(transactions, filename):
    """
    Save the generated transactions to a CSV file.
    This function takes a list of transaction records and writes them to a file, ensuring each session's data is stored separately and clearly.

    Args:
        transactions (list): List of formatted transaction strings.
        filename (str): Path to the file where transactions will be saved.
    """
    logging.info(f"Writing transactions to {filename}.")
    header = "transaction_time,account_number,transaction_type,amount,source_file\n"
    with open(filename, 'w') as file:
        file.write(header)
        file.writelines(transactions)

def main():
    """
    Main execution function to continuously generate and write transaction data.
    This function runs indefinitely, simulating a real-world system where transactions are constantly occurring and being logged.
    """
    num_accounts = random.randint(1, 100)  # Generate a random number of accounts
    accounts = generate_random_accounts(num_accounts)
    cnt = 0
    while True:
        cnt += 1
        logging.info(f"Starting transaction set {cnt}.")
        transactions = []
        num_sets = int(random.uniform(5, 15))
        for _ in range(num_sets):
            filename = f"transactions{cnt}.csv"
            transactions.extend(generate_transactions(accounts, filename))
        # Limit the number of transactions per file to enhance manageability
        transactions = transactions[:1000]
        filename = f"stream/input/transactions{cnt}.csv"
        write_transactions_to_file(transactions, filename)
        # Simulate a delay between file creations to mimic real-world operation pacing
        time.sleep(random.uniform(10, 160))

if __name__ == "__main__":
    main()